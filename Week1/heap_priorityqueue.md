# Priority Queue와 Heap 정렬

## Priority Queue (우선순위 큐)

우선순위 큐는 각 요소가 우선순위를 가진 큐의 형태로, 요소가 추가될 때 그 우선순위에 따라 정렬됩니다. 우선순위가 가장 높은 요소가 먼저 제거됩니다. 이러한 큐는 일반적으로 힙(Heap)을 이용하여 구현됩니다.

## Heap (힙)

힙은 완전 이진 트리의 일종으로, 힙 속성(부모 노드가 자식 노드보다 크거나 작은)을 만족합니다. 힙은 크게 두 종류가 있습니다:
- 최대 힙(Max-Heap): 부모 노드가 자식 노드보다 크거나 같습니다.
- 최소 힙(Min-Heap): 부모 노드가 자식 노드보다 작거나 같습니다.

힙은 주로 배열로 구현되며, 배열의 첫 번째 요소(인덱스 0)는 힙의 루트를 나타냅니다.

## Heap Sort (힙 정렬)

힙 정렬은 힙을 이용한 정렬 방법으로, 효율적인 시간 복잡도를 가진다는 장점이 있습니다. 힙 정렬의 기본적인 과정은 다음과 같습니다:

1. 입력된 배열을 힙 구조로 변환합니다.
2. 힙에서 최대 원소(또는 최소 원소)를 배열의 끝으로 이동시키고, 힙의 크기를 줄입니다.
3. 힙의 재구성을 수행합니다.
4. 위 과정을 반복합니다.

### 힙 정렬의 시간 복잡도
힙 정렬의 시간 복잡도는 모든 경우에 O(n log n)입니다. 초기 힙 구성에 O(n)의 시간이 걸리며, 각 원소에 대해 삭제 및 재구성 과정이 log n의 시간을 요구하기 때문입니다.

## 힙 정렬의 장점

힙 정렬은 다른 정렬 알고리즘과 비교했을 때 다음과 같은 장점을 가집니다:

- **안정적인 시간 복잡도**: 힙 정렬은 최악의 경우에도 O(n log n)의 시간 복잡도를 유지합니다.
- **추가 메모리 사용이 적음**: 힙 정렬은 주어진 배열 내에서 정렬을 수행하므로, 별도의 추가 메모리가 필요하지 않습니다.
- **In-place 정렬**: 힙 정렬은 추가적인 메모리를 거의 사용하지 않고 주어진 배열 내에서 원소들을 재배치합니다.

힙 정렬의 주요 단점은 정렬 과정 중 원소들이 안정적으로 위치를 유지하지 않는다는 것입니다(즉, 동일한 원소가 원래의 순서를 유지하지 않을 수 있습니다).


```cpp
#include <iostream>
#include <vector>

using namespace std;

// 힙을 재구성하는 함수
void heapify(vector<int>& arr, int n, int i) {
    int largest = i; // 가장 큰 값을 가진 노드의 인덱스 (초기에는 현재 노드로 설정)
    int left = 2 * i + 1; // 왼쪽 자식 노드의 인덱스
    int right = 2 * i + 2; // 오른쪽 자식 노드의 인덱스

    // 왼쪽 자식이 현재 노드보다 크면 largest를 왼쪽 자식으로 갱신
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // 오른쪽 자식이 현재 노드보다 크면 largest를 오른쪽 자식으로 갱신
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // largest가 현재 노드가 아니면 스왑하고, 스왑된 자식 노드에 대해 다시 heapify 호출
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

// 힙 정렬을 수행하는 함수
void heapSort(vector<int>& arr) {
    int n = arr.size();

    // 배열을 힙 구조로 만드는 과정
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // 하나씩 원소를 빼면서 힙을 재구성
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]); // 힙의 루트(최댓값)를 배열의 마지막 요소와 교환
        heapify(arr, i, 0); // 루트에서 시작하여 힙을 재구성
    }
}

int main() {
    vector<int> arr = {12, 11, 13, 5, 6, 7};
    cout << "Original array: ";
    for (int num : arr)
        cout << num << " ";
    cout << endl;

    heapSort(arr); // 배열을 힙 정렬

    cout << "Sorted array: ";
    for (int num : arr)
        cout << num << " ";
    cout << endl;

    return 0;
}
// heapify 함수 설명:
// 이 함수는 주어진 노드 i를 루트로 하여 최대 힙 속성을 유지하게 합니다.
// 예를 들어, arr = [4, 10, 3, 5, 1] 에서 i = 0 이면:
//       4(0)
//      /   \
//   10(1)  3(2)
//   /  \
// 5(3) 1(4)
// 최대 힙 조건을 만족하지 않으므로 10과 4를 교환합니다.

// heapSort 함수 설명:
// 첫째, 주어진 배열을 최대 힙으로 만듭니다.
// 예: 초기 배열 [3, 1, 4, 5, 2]는 다음과 같이 최대 힙으로 변환됩니다.
//         3(0)                  5(0)
//        /   \       ->        /   \
//     1(1)   4(2)           1(1)   4(2)
//     / \                  / \
//  5(3) 2(4)             3(3) 2(4)
// 이제 배열은 최대 힙 속성을 만족합니다.

// 그 다음으로, 배열의 마지막 요소와 최대 힙의 루트(가장 큰 원소)를 교환하고,
// 힙의 크기를 하나 줄인 뒤, 새로운 루트에 대해 heapify를 호출하여 최대 힙을 유지합니다.
// 이 과정은 배열이 완전히 정렬될 때까지 반복됩니다.
// 예: 첫 번째 교환 후 배열과 힙 구조:
//         2(0)                  4(0)
//        /   \       ->        /   \
//     1(1)   4(2)           1(1)   2(2)
//     /                  /
//  5(3)                3(3)
// 이 상태에서 heapify를 호출하면 4가 새로운 루트로 올라가고, 2와 3은 자식 노드가 됩니다.

// main 함수에서는 배열의 초기 상태와 최종 정렬된 상태를 출력하여
// 프로그램의 입출력을 관찰할 수 있습니다.


```