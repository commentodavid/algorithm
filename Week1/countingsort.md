# 카운팅 정렬

## 카운팅 정렬 (Counting Sort)
카운팅 정렬은 정수나 정렬 가능한 객체들의 개수가 정해져 있고, 그 범위가 작을 때 가장 효율적입니다. 이 정렬 방식은 각 항목이 몇 번 등장하는지 세는 것에서부터 시작하여, 그 개수를 사용해 직접 정렬을 수행합니다.

### 가장 효율적인 경우
- **데이터 범위가 작고**, 항목들이 **이 범위 내에 균일하게 분포**되어 있을 때 카운팅 정렬은 매우 효율적입니다.
- 예를 들어, 100개의 학생이 있고, 점수가 0점에서 100점 사이라면 카운팅 정렬은 이상적입니다.

### 제한점
- 카운팅 정렬은 **데이터의 범위가 넓어질수록 메모리 사용량이 증가**합니다. 만약 1부터 1,000,000까지의 숫자 중 하나를 가진 100개의 데이터를 정렬한다면, 대부분의 메모리는 사용되지 않는 공간으로 낭비됩니다.
- 비정수 데이터에는 적용이 어렵습니다.

### 복잡도
- 카운팅 정렬의 시간 복잡도는 \(O(n + k)\)이며, 여기서 \(n\)은 리스트의 길이, \(k\)는 입력의 범위입니다.

```cpp
#include <iostream>

void simpleCountingSort(int arr[], int n, int maxVal) {
    int count[101] = {0};  // 데이터 범위가 0 ~ 100을 가정

    // 데이터의 빈도수를 계산
    for (int i = 0; i < n; i++) {
        count[arr[i]]++;
    }
    // count 상태: [0, 1, 2, 2, 1, 0, 0, 0, 1, 0, ...] 
    // 설명: 1이 1번, 2가 2번, 3이 2번, 4가 1번, 8이 1번 나타난다는 의미

    // 출력 배열 생성
    int index = 0;
    for (int i = 0; i <= maxVal; i++) {
        while (count[i] > 0) {
            arr[index++] = i;
            count[i]--;
            // 배열 arr의 상태를 각 i 값의 추가 후에 출력
            // 예를 들어 i = 1일 때:
            // arr 상태: [1, ?, ?, ?, ?, ?, ?]
            // 예를 들어 i = 2일 때, 두 번 추가 후:
            // arr 상태: [1, 2, 2, ?, ?, ?, ?]
            // i = 4일 때:
            // arr 상태: [1, 2, 2, 4, ?, ?, ?]
            // i = 8일 때:
            // arr 상태: [1, 2, 2, 4, 8, ?, ?]
        }
    }
}

int main() {
    int data[] = {4, 2, 2, 8, 3, 3, 1};
    int n = sizeof(data) / sizeof(data[0]);
    int maxVal = 8; // 최댓값을 알고 있어야 함
    simpleCountingSort(data, n, maxVal);
    for (int i = 0; i < n; i++) {
        std::cout << data[i] << " ";
    }
    std::cout << std::endl;
    return 0;
}
```